@定义中断向量表,.section是段
.section .vectors, "ax"  @%progbits@定义一个存放中断向量表的段，.vector
@.align 4
  b _start      @当重置程序时，跳到_start执行
  b evt_undef   @其他中断向量为空，表示死循环
  b evt_undef
  b evt_undef
  b evt_undef
  .word 0
  b service_irq  @当设备硬件发出硬件中断请求，跳转到这里执行
  b evt_undef

@定义所需要的数据
.data
@.align 4

count:      .word  0          
direction:  .word  1   @用于按键中断转向，当没按下按键，direction为1，数据向上递增，当direction为-1，数据向下递增       

@定义七段数码管0-9
seg7_table:
.word 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F

.text
.global _start
_start:
  @初始化步骤，固定流程
  mov r1, #0b11010010 @0是低位，1是高位
  msr cpsr_c, r1
  ldr sp, =0xFFFFFFFC @设置栈指针为irq模式
  mov r1, #0b11010011
  msr cpsr, r1        @设置为supervisor模式
  ldr sp, =0x3FFFFFFC
  @跳到gic config去处理复杂问题，gic config有专门的模板，只需要按照例程代码作微小改动即可
  bl config_gic          

  @设置定时器
  ldr r0, =0xFF202000
  mov r1, #8
  str r1, [r0, #4]       
  str r1, [r0]           
  ldr r1, =100000000 @由于时钟频率是100mhz，每秒有100000000个时钟周期
  str r1, [r0, #8]   @虽然以十进制写入，但是在寄存器会以二进制处理    
  lsr r1, #16
  str r1, [r0, #12]      
  mov r1, #7
  str r1, [r0, #4]       

  @配置按键中断，将0b0001写入寄存器中说明按下按键1（但是修改r1的值会发生错误）
  ldr r0, =0xFF200050
  mov r1, #1
  str r1, [r0, #8]
  
  @使能irq中断
  mov r0, #0b01010011
  msr cpsr_c, r0

@主程序是一个死循环，所有的都交给中断程序处理
idle:
  b idle

@没有定义的中断进入死循环
evt_undef:
  b evt_undef

@irq的中断服务程序，当硬件中断响应，调用子程序
service_irq:
  push {r0-r7, r12, lr} @入栈保存当前寄存器的值，防止中断主程序数据

  ldr r4, =0xFFFEC100
  ldr r5, [r4, #12]

  cmp r5, #72
  beq timer_isr

  cmp r5, #73
  beq button_isr

exit_irq:
  str r5, [r4, #16]
  pop {r0-r7, r12, lr} @出栈恢复寄存器的值
  @进入中断时，lr自动加4，如果再出中断时不减回这个4，就会跳过一条指令
  subs pc, lr, #4 @从irq模式返回到中断的程序，pc是储存下一条要执行指令地址的寄存器，subs更新cpsr的状态

@配置定时器中断
timer_isr:
  @初始化定时器，让定时器重新开始计时
  ldr r0, =0xFF202000
  mov r1, #1
  str r1, [r0] @清理定时器超时标志

  ldr r0, =count
  ldr r1, [r0]

  ldr r3, =direction @可以是1或者-1，如果为-1就是减法效果
  ldr r3, [r3]
  adds r1, r1, r3 @加s的原因是更新cspr的条件标志位，r1可以用于后面ble，cmp等判断

  ldr r2, =0 @小于0的话，设为999
  cmp r1, r2
  blt set_to_max

  ldr r2, =999
  cmp r1, r2
  ble valid_count
  ldr r1, =0
  b store_count

set_to_max:
  ldr r1, =999

valid_count:
store_count:
  str r1, [r0]
  bl display_count
  b exit_irq

display_count:
  push {lr}

  mov r12, r1 @r1是计数值
  mov r0, r12
  ldr r1, =10
  bl __modsi3 @保存返回地址
  mov r2, r0 @r2=-10,r0=-10

  mov r0, r12@r0 = 1
  ldr r1, =10
  bl __divsi3
  mov r12, r0@r2 = 0,r0=1,r12 =1

  mov r0, r12
  ldr r1, =10
  bl __modsi3
  mov r3, r0

  mov r0, r12
  ldr r1, =10
  bl __divsi3
  mov r1, r0

  ldr r0, =seg7_table
  lsl r12, r2, #2 @r12 = r2 << 2
  ldr r2, [r0, r12] @将r0+r12的地址的内容写入r2中
  lsl r12, r3, #2
  ldr r3, [r0, r12]
  lsl r12, r1, #2
  ldr r1, [r0, r12]

  lsl r3, r3, #8
  orr r2, r2, r3
  lsl r1, r1, #16
  orr r2, r2, r1

  ldr r0, =0xFF200020
  str r2, [r0]

  pop {lr}
  bx lr
  
__divsi3:
  push {r2, r3, lr}
  mov r2, #0
div_loop:
  cmp r0, r1
  blt div_end
  subs r0, r0, r1
  adds r2, r2, #1
  b div_loop
div_end:
  mov r0, r2
  pop {r2, r3, lr}
  bx lr

__modsi3:
  push {r2, r3, lr}
  mov r2, r0
  bl __divsi3
  mul r3, r0, r1 @无符号整数乘法运算，10
  subs r0, r2, r3 @-10
  pop {r2, r3, lr}
  bx lr

button_isr:
  ldr r0, =0xFF200050
  mov r1, #1
  str r1, [r0, #12]

  ldr r0, =direction
  ldr r1, [r0]
  rsb r1, r1, #0 @相当于用0-r1
  str r1, [r0]
  b exit_irq
  
@固定操作，如果要改变中断改变里面的参数即可
.global config_gic
config_gic:
  push {lr}

  mov r0, #72
  mov r1, #1
  bl config_interrupt

  mov r0, #73
  mov r1, #1
  bl config_interrupt

  ldr r0, =0xFFFEC100
  ldr r1, =0xFFFF
  str r1, [r0, #4]
  mov r1, #1
  str r1, [r0]
  
  ldr r0, =0xFFFED000
  str r1, [r0]

  pop {lr}
  bx lr

@固定操作，如果要改变中断改变里面的参数即可
config_interrupt:
  push {r4-r5, lr}

  lsr r4, r0, #5
  ldr r2, =0xFFFED100
  add r4, r2, r4, LSL #2
  and r2, r0, #0x1F
  mov r5, #1
  lsl r2, r5, r2
  ldr r3, [r4]
  orr r3, r3, r2
  str r3, [r4]

  ldr r2, =0xFFFED800
  add r4, r2, r0
  strb r1, [r4]

  pop {r4-r5, lr}
  bx lr



.end
